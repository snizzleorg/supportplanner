import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import dayjs from 'dayjs';
import { DAVClient } from 'tsdav';
import IcalExpander from 'ical-expander';
import path from 'path';
import { fileURLToPath } from 'url';
import NodeCache from 'node-cache';
import fs from 'fs';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load event types configuration
let eventTypes = {
  _default: {
    color: '#7f8c8d',
    borderColor: '#6c7a7d'
  }
};

try {
  const eventTypesConfig = JSON.parse(fs.readFileSync(path.join(__dirname, 'event-types.json'), 'utf8'));
  eventTypes = { ...eventTypes, ...eventTypesConfig.eventTypes };
  console.log('Loaded event types configuration');
} catch (err) {
  console.error('Failed to load event-types.json, using default colors', err);
}

const app = express();
app.use(cors());
app.use(express.json({ limit: '2mb' }));
app.use(express.static(path.join(__dirname, 'public')));

// Test endpoint to verify event type configuration
app.get('/api/event-types', (req, res) => {
  res.json({
    eventTypes,
    configFile: fs.readFileSync(path.join(__dirname, 'event-types.json'), 'utf8')
  });
});

// Serve dynamic CSS with configured colors
app.get('/dynamic-styles.css', (req, res) => {
  console.log('Generating dynamic CSS with event types:', Object.keys(eventTypes));
  let css = `/* Dynamic event type styles */
.vis-item {
  border-radius: 4px;
  border: none;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  transition: all 0.2s ease;
  padding: 2px 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-size: 12px;
  font-weight: 500;
  line-height: 1.3;
  min-height: 24px;
}

/* Base styles for all event types */
.vis-item[class*="event-type-"] {
  color: #000000;
  text-shadow: none;
  border: 1px solid rgba(0,0,0,0.2);
}

/* Ensure text is visible on all background colors */
.vis-item .vis-item-content {
  position: relative;
  z-index: 1;
  padding: 2px 4px;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}
`;

  // Add styles for each event type with black text
  Object.entries(eventTypes).forEach(([type, style]) => {
    if (type === '_default') return; // Skip default, handled separately
    
    const bgColor = style.color || eventTypes._default.color;
    const borderColor = style.borderColor || eventTypes._default.borderColor;
    const typeLower = type.toLowerCase();
    
    css += `
.vis-item.event-type-${typeLower} {
  background-color: ${bgColor} !important;
  border-color: ${borderColor} !important;
  color: #000000 !important;
  text-shadow: none !important;
}

/* Hover effect */
.vis-item.event-type-${typeLower}:hover {
  filter: brightness(1.05) !important;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3) !important;
  z-index: 10 !important;
}
`;
  });

  // Add default styles
  css += `
/* Fallback for other event types */
.vis-item[class^="event-type-"]:not([class*="event-type-"]) {
  background-color: ${eventTypes._default.color};
  border-color: ${eventTypes._default.borderColor};
  color: #000000;
  text-shadow: none;
}

/* Make all-day events fully opaque */
.vis-item.all-day-event {
  opacity: 1;
}

/* Hover effect for all events */
.vis-item:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  z-index: 20;
}

/* Ensure text is not cut off */
.vis-item .vis-item-content {
  overflow: visible;
  white-space: normal;
  word-break: break-word;
  hyphens: auto;
}
`;

  res.type('text/css');
  res.send(css);
});

// Enhanced cache configuration with memory management
const cache = new NodeCache({
  stdTTL: 600, // 10 min TTL
  checkperiod: 120,
  maxKeys: 100, // Limit number of cache entries
  useClones: false, // Better performance
  deleteOnExpire: true
});

const serverUrl = process.env.NEXTCLOUD_URL;
const username = process.env.NEXTCLOUD_USERNAME;
const password = process.env.NEXTCLOUD_PASSWORD;

function requireEnv() {
  if (!serverUrl || !username || !password) {
    throw new Error('Missing NEXTCLOUD_URL, NEXTCLOUD_USERNAME or NEXTCLOUD_PASSWORD in environment');
  }
}

async function getClient() {
  requireEnv();
  const client = new DAVClient({
    serverUrl,
    credentials: { username, password },
    authMethod: 'Basic',
    defaultAccountType: 'caldav',
  });
  await client.login();
  return client;
}

app.get('/api/calendars', async (req, res) => {
  try {
    const client = await getClient();
    const calendars = await client.fetchCalendars();
    // Shape a small response
    const result = calendars.map((c) => ({
      url: c.url,
      displayName: c.displayName || c.url,
      description: c.description || '',
      ctag: c.ctag || '',
      components: c.components || [],
      color: c.color || null,
    }));
    res.json({ calendars: result });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: err.message || 'Failed to fetch calendars' });
  }
});

// Pre-compile regex for better performance
const whitespaceRegex = /\s+/;

// Process a single calendar object
async function processCalendarObject(obj) {
  try {
    const ics = obj.data;
    const icalExpander = new IcalExpander({ ics, maxIterations: 1000 });
    return icalExpander.between(startDate, endDate);
  } catch (error) {
    console.error('Error processing calendar object:', error);
    return { events: [], occurrences: [] };
  }
}

// Process events from a single calendar
async function processCalendar(cal, startDate, endDate, startISO, endISO) {
  const groupId = `cal-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
  const timelineItems = [];
  
  try {
    const cacheKey = `events_${cal.url}_${startISO}_${endISO}`;
    let eventsData = cache.get(cacheKey);
    
    if (!eventsData) {
      const objects = await client.fetchCalendarObjects({
        calendar: cal,
        timeRange: { start: startISO, end: endISO }
      });
      
      if (!objects || objects.length === 0) {
        return { items: [], group: null };
      }
      
      // Process all objects in parallel
      const results = await Promise.all(objects.map(processCalendarObject));
      
      // Combine all results
      eventsData = {
        events: results.flatMap(r => r.events.map(event => ({
          uid: event.uid,
          summary: event.summary,
          description: event.description,
          location: event.location,
          start: event.startDate.toJSDate().toISOString(),
          end: event.endDate.toJSDate().toISOString(),
          allDay: !event.startDate.hour && !event.startDate.minute
        }))),
        occurrences: results.flatMap(r => r.occurrences.map(occurrence => ({
          startDate: occurrence.startDate.toJSDate().toISOString(),
          endDate: occurrence.endDate.toJSDate().toISOString(),
          item: {
            uid: occurrence.item.uid,
            summary: occurrence.item.summary,
            description: occurrence.item.description,
            location: occurrence.item.location
          }
        })))
      };
      
      // Cache the result for 5 minutes
      cache.set(cacheKey, eventsData, 300);
    }
    
    // Process events
    const now = Date.now();
    
    // Process regular events
    for (const event of eventsData.events) {
      const eventEnd = new Date(event.end).getTime();
      if (eventEnd < now) continue; // Skip past events
      
      const summary = event.summary || 'Event';
      const firstWordLower = summary.trim().split(whitespaceRegex)[0].toLowerCase();
      
      timelineItems.push({
        id: `${groupId}_${event.uid}_${event.start}_${event.end}`,
        group: groupId,
        content: summary,
        start: event.start,
        end: event.end,
        title: event.description || '',
        summary: summary,
        description: event.description,
        location: event.location,
        className: `event-type-${firstWordLower} ${event.allDay ? 'all-day-event' : ''}`
      });
    }
    
    // Process recurring events
    for (const occ of eventsData.occurrences) {
      const occEnd = new Date(occ.endDate).getTime();
      if (occEnd < now) continue; // Skip past events
      
      const summary = occ.item.summary || 'Event';
      const firstWordLower = summary.trim().split(whitespaceRegex)[0].toLowerCase();
      
      timelineItems.push({
        id: `${groupId}_rec_${occ.item.uid}_${occ.startDate}_${occ.endDate}`,
        group: groupId,
        content: summary,
        start: occ.startDate,
        end: occ.endDate,
        title: occ.item.description || '',
        summary: summary,
        description: occ.item.description,
        location: occ.item.location,
        className: `event-type-${firstWordLower} recurring-event`
      });
    }
    
    return {
      items: timelineItems,
      group: { id: groupId, content: cal.displayName || cal.url, color: cal.color || undefined }
    };
    
  } catch (error) {
    console.error(`Error processing calendar ${cal.displayName || cal.url}:`, error);
    return { items: [], group: null };
  }
}

// Process calendars in batches with concurrency control
async function processCalendars(calendars, startDate, endDate, startISO, endISO, concurrency = 3) {
  const results = [];
  const groups = [];
  
  for (let i = 0; i < calendars.length; i += concurrency) {
    const batch = calendars.slice(i, i + concurrency);
    const batchResults = await Promise.all(
      batch.map(cal => processCalendar(cal, startDate, endDate, startISO, endISO))
    );
    
    for (const { items, group } of batchResults) {
      if (group) groups.push(group);
      results.push(...items);
    }
  }
  
  return { items: results, groups };
}

app.post('/api/events', async (req, res) => {
  try {
    const { calendarUrls, from, to } = req.body || {};
    console.log('[events] request', { from, to, count: Array.isArray(calendarUrls) ? calendarUrls.length : 0 });
    
    if (!Array.isArray(calendarUrls) || calendarUrls.length === 0) {
      return res.status(400).json({ error: 'calendarUrls must be a non-empty array' });
    }
    if (!from || !to) {
      return res.status(400).json({ error: 'from and to dates are required' });
    }
    
    // Set cache control headers
    res.set('Cache-Control', 'public, max-age=300'); // 5 min cache
    
    const start = dayjs(from).startOf('day');
    const end = dayjs(to).endOf('day');
    if (!start.isValid() || !end.isValid()) {
      return res.status(400).json({ error: 'Invalid from/to dates' });
    }
    
    const startDate = start.toDate();
    const endDate = end.toDate();
    const startISO = startDate.toISOString();
    const endISO = endDate.toISOString();
    
    // Get client and calendars
    const client = await getClient();
    const cacheKey = `calendars_${calendarUrls.sort().join('_')}`;
    let allCalendars = cache.get(cacheKey);
    
    if (!allCalendars) {
      allCalendars = await client.fetchCalendars();
      cache.set(cacheKey, allCalendars, 3600); // Cache for 1 hour
    }
    
    const urlSet = new Set(calendarUrls);
    const selected = allCalendars.filter(cal => urlSet.has(cal.url));
    
    if (selected.length === 0) {
      return res.json({ items: [], groups: [] });
    }
    
    // Process all calendars with concurrency control
    const { items, groups } = await processCalendars(selected, startDate, endDate, startISO, endISO, 3);
    const processedAny = items.length > 0;
    
    if (!processedAny) {
      console.warn('[events] no calendar objects processed');
    }
    
    console.log(`[events] returning ${items.length} items from ${groups.length} calendars`);
    
    // Send the response
    res.json({ items, groups });
  } catch (err) {
    console.error('[events] fatal error', err && err.stack ? err.stack : err);
    res.status(500).json({ error: err.message || 'Failed to fetch events' });
  }
          eventsData = {
            events: results.flatMap(r => r.events.map(event => ({
              uid: event.uid,
              summary: event.summary,
              description: event.description,
              location: event.location,
              start: event.startDate.toJSDate().toISOString(),
              end: event.endDate.toJSDate().toISOString(),
              allDay: !event.startDate.hour && !event.startDate.minute
            }))),
            occurrences: results.flatMap(r => r.occurrences.map(occurrence => ({
              startDate: occurrence.startDate.toJSDate().toISOString(),
              endDate: occurrence.endDate.toJSDate().toISOString(),
              item: {
                uid: occurrence.item.uid,
                summary: occurrence.item.summary,
                description: occurrence.item.description,
                location: occurrence.item.location
              }
            })))
          };
          
          // Cache the result
          cache.set(cacheKey, eventsData, 300); // Cache for 5 minutes
        }
        
        // Process events and return timeline items
        const timelineItems = [];
        const now = Date.now();
        
        // Process regular events
        for (const event of eventsData.events) {
          const summary = event.summary || 'Event';
          const firstWordOriginal = summary.trim().split(whitespaceRegex)[0];
          const firstWordLower = firstWordOriginal.toLowerCase();
          
          // Skip events that end before now
          const eventEnd = new Date(event.end).getTime();
          if (eventEnd < now) continue;
          
          // ... rest of the event processing code ...
          // (Keep the existing event processing logic here)
          
          timelineItems.push({
            id: `${groupId}_${event.uid}_${event.start}_${event.end}`,
            group: groupId,
            content: summary,
            start: event.start,
            end: event.end,
            title: event.description || '',
            summary: summary,
            description: event.description,
            location: event.location,
            className: `event-type-${firstWordLower} ${event.allDay ? 'all-day-event' : ''}`
          });
        }
        
        // Process recurring events
        for (const occ of eventsData.occurrences) {
          const summary = occ.item.summary || 'Event';
          const firstWordOriginal = summary.trim().split(whitespaceRegex)[0];
          const firstWordLower = firstWordOriginal.toLowerCase();
          
          // Skip events that end before now
          const occEnd = new Date(occ.endDate).getTime();
          if (occEnd < now) continue;
          
          // ... rest of the occurrence processing code ...
          // (Keep the existing occurrence processing logic here)
          
          timelineItems.push({
            id: `${groupId}_rec_${occ.item.uid}_${occ.startDate}_${occ.endDate}`,
            group: groupId,
            content: summary,
            start: occ.startDate,
            end: occ.endDate,
            title: occ.item.description || '',
            summary: summary,
            description: occ.item.description,
            location: occ.item.location,
            className: `event-type-${firstWordLower} recurring-event`
          });
        }
        
        return timelineItems;
      } catch (error) {
        console.error(`Error processing calendar ${cal.displayName || cal.url}:`, error);
        return [];
      }
    };

    // Process all calendars with concurrency control
    try {
      const { items, groups } = await processCalendars(selected, startDate, endDate, startISO, endISO, 3);
      const processedAny = items.length > 0;
      
      if (!processedAny && items.length === 0 && groups.length === 0) {
        console.warn('[events] no calendar objects processed; returning empty result');
      }
      
      console.log(`[events] returning ${items.length} items from ${groups.length} calendars`);
      
      // Send the response
      return res.json({ items, groups });
    } catch (err) {
      console.error('[events] fatal error', err && err.stack ? err.stack : err);
      return res.status(500).json({ error: err.message || 'Failed to fetch events' });
    }
});

// Receive client-side logs/errors for debugging
app.post('/api/client-log', (req, res) => {
  try {
    const payload = req.body || {};
    console.log('[ClientLog]', JSON.stringify(payload));
    res.json({ ok: true });
  } catch (e) {
    console.error('Failed to log client message', e);
    res.status(500).json({ error: 'Failed to log' });
  }
});

// Fallback to index.html for root
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

const PORT = process.env.PORT || 5173;
app.listen(PORT, () => {
  console.log(`CalDAV Gantt server running at http://localhost:${PORT}`);
});
